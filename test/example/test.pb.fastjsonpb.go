// Code generated by protoc-gen-fastjsonpb. DO NOT EDIT.
// source:test.proto

package example

import (
	buffer "github.com/superjsf2010/protoc-gen-fastjsonpb/x/buffer"
	jsonparser "github.com/superjsf2010/protoc-gen-fastjsonpb/x/jsonparser"
	sync "sync"
)

func (x *Msg) FastMarshal(buf *buffer.Buffer) {
	if x == nil {
		buf.WriteString("{}")
	}
	buf.WriteString("{")
	if !x.IsEmptyBol() {
		buf.WriteString("\"bol\"")
		buf.WriteString(":")
		buf.WriteBool(x.GetBol())
		buf.WriteString(",")
	}

	if !x.IsEmptyStr() {
		buf.WriteString("\"str\"")
		buf.WriteString(":")
		buf.WriteString("\"" + x.GetStr() + "\"")
		buf.WriteString(",")
	}

	if !x.IsEmptyIn32() {
		buf.WriteString("\"in32\"")
		buf.WriteString(":")
		buf.WriteInt32(x.GetIn32())
		buf.WriteString(",")
	}

	if !x.IsEmptyIn64() {
		buf.WriteString("\"in64\"")
		buf.WriteString(":")
		buf.WriteInt64(x.GetIn64())
		buf.WriteString(",")
	}

	if !x.IsEmptyUin32() {
		buf.WriteString("\"uin32\"")
		buf.WriteString(":")
		buf.WriteUint32(x.GetUin32())
		buf.WriteString(",")
	}

	if !x.IsEmptyUin64() {
		buf.WriteString("\"uin64\"")
		buf.WriteString(":")
		buf.WriteUint64(x.GetUin64())
		buf.WriteString(",")
	}

	if !x.IsEmptyFlt32() {
		buf.WriteString("\"flt32\"")
		buf.WriteString(":")
		buf.WriteFloat32(x.GetFlt32())
		buf.WriteString(",")
	}

	if !x.IsEmptyFlt64() {
		buf.WriteString("\"flt64\"")
		buf.WriteString(":")
		buf.WriteFloat64(x.GetFlt64())
		buf.WriteString(",")
	}

	if !x.IsEmptyByts() {
		buf.WriteString("\"byts\"")
		buf.WriteString(":")
		buf.WriteBytes(x.GetByts())
		buf.WriteString(",")
	}

	if !x.IsEmptyBolArr() {
		buf.WriteString("\"bolArr\"")
		buf.WriteString(":")
		buf.WriteString("[")
		for i, _ := range x.BolArr {
			buf.WriteBool(x.BolArr[i])
			buf.WriteString(",")
		}
		buf.FixSymbol()
		buf.WriteString("]")
		buf.WriteString(",")
	}

	if !x.IsEmptyStrArr() {
		buf.WriteString("\"strArr\"")
		buf.WriteString(":")
		buf.WriteString("[")
		for i, _ := range x.StrArr {
			buf.WriteString("\"" + x.StrArr[i] + "\"")
			buf.WriteString(",")
		}
		buf.FixSymbol()
		buf.WriteString("]")
		buf.WriteString(",")
	}

	if !x.IsEmptyIn32Arr() {
		buf.WriteString("\"in32Arr\"")
		buf.WriteString(":")
		buf.WriteString("[")
		for i, _ := range x.In32Arr {
			buf.WriteInt32(x.In32Arr[i])
			buf.WriteString(",")
		}
		buf.FixSymbol()
		buf.WriteString("]")
		buf.WriteString(",")
	}

	if !x.IsEmptyIn64Arr() {
		buf.WriteString("\"in64Arr\"")
		buf.WriteString(":")
		buf.WriteString("[")
		for i, _ := range x.In64Arr {
			buf.WriteInt64(x.In64Arr[i])
			buf.WriteString(",")
		}
		buf.FixSymbol()
		buf.WriteString("]")
		buf.WriteString(",")
	}

	if !x.IsEmptyUin32Arr() {
		buf.WriteString("\"uin32Arr\"")
		buf.WriteString(":")
		buf.WriteString("[")
		for i, _ := range x.Uin32Arr {
			buf.WriteUint32(x.Uin32Arr[i])
			buf.WriteString(",")
		}
		buf.FixSymbol()
		buf.WriteString("]")
		buf.WriteString(",")
	}

	if !x.IsEmptyUin64Arr() {
		buf.WriteString("\"uin64Arr\"")
		buf.WriteString(":")
		buf.WriteString("[")
		for i, _ := range x.Uin64Arr {
			buf.WriteUint64(x.Uin64Arr[i])
			buf.WriteString(",")
		}
		buf.FixSymbol()
		buf.WriteString("]")
		buf.WriteString(",")
	}

	if !x.IsEmptyFlt32Arr() {
		buf.WriteString("\"flt32Arr\"")
		buf.WriteString(":")
		buf.WriteString("[")
		for i, _ := range x.Flt32Arr {
			buf.WriteFloat32(x.Flt32Arr[i])
			buf.WriteString(",")
		}
		buf.FixSymbol()
		buf.WriteString("]")
		buf.WriteString(",")
	}

	if !x.IsEmptyFlt64Arr() {
		buf.WriteString("\"flt64Arr\"")
		buf.WriteString(":")
		buf.WriteString("[")
		for i, _ := range x.Flt64Arr {
			buf.WriteFloat64(x.Flt64Arr[i])
			buf.WriteString(",")
		}
		buf.FixSymbol()
		buf.WriteString("]")
		buf.WriteString(",")
	}

	if !x.IsEmptyBytsArr() {
		buf.WriteString("\"bytsArr\"")
		buf.WriteString(":")
		buf.WriteString("[")
		for i, _ := range x.BytsArr {
			buf.WriteBytes(x.BytsArr[i])
			buf.WriteString(",")
		}
		buf.FixSymbol()
		buf.WriteString("]")
		buf.WriteString(",")
	}

	if !x.IsEmptyBolMap() {
		buf.WriteString("\"bolMap\"")
		buf.WriteString(":")
		buf.WriteString("{")
		for k, _ := range x.BolMap {
			buf.WriteString("\"" + k + "\"")
			buf.WriteString(":")
			buf.WriteBool(x.BolMap[k])
			buf.WriteString(",")
		}
		buf.FixSymbol()
		buf.WriteString("}")
		buf.WriteString(",")
	}

	if !x.IsEmptyStringMap() {
		buf.WriteString("\"stringMap\"")
		buf.WriteString(":")
		buf.WriteString("{")
		for k, _ := range x.StringMap {
			buf.WriteString("\"" + k + "\"")
			buf.WriteString(":")
			buf.WriteString("\"" + x.StringMap[k] + "\"")
			buf.WriteString(",")
		}
		buf.FixSymbol()
		buf.WriteString("}")
		buf.WriteString(",")
	}

	if !x.IsEmptyIn32Map() {
		buf.WriteString("\"in32Map\"")
		buf.WriteString(":")
		buf.WriteString("{")
		for k, _ := range x.In32Map {
			buf.WriteString("\"" + k + "\"")
			buf.WriteString(":")
			buf.WriteInt32(x.In32Map[k])
			buf.WriteString(",")
		}
		buf.FixSymbol()
		buf.WriteString("}")
		buf.WriteString(",")
	}

	if !x.IsEmptyIn64Map() {
		buf.WriteString("\"in64Map\"")
		buf.WriteString(":")
		buf.WriteString("{")
		for k, _ := range x.In64Map {
			buf.WriteString("\"" + k + "\"")
			buf.WriteString(":")
			buf.WriteInt64(x.In64Map[k])
			buf.WriteString(",")
		}
		buf.FixSymbol()
		buf.WriteString("}")
		buf.WriteString(",")
	}

	if !x.IsEmptyUin32Map() {
		buf.WriteString("\"uin32Map\"")
		buf.WriteString(":")
		buf.WriteString("{")
		for k, _ := range x.Uin32Map {
			buf.WriteString("\"" + k + "\"")
			buf.WriteString(":")
			buf.WriteUint32(x.Uin32Map[k])
			buf.WriteString(",")
		}
		buf.FixSymbol()
		buf.WriteString("}")
		buf.WriteString(",")
	}

	if !x.IsEmptyUin64Map() {
		buf.WriteString("\"uin64Map\"")
		buf.WriteString(":")
		buf.WriteString("{")
		for k, _ := range x.Uin64Map {
			buf.WriteString("\"" + k + "\"")
			buf.WriteString(":")
			buf.WriteUint64(x.Uin64Map[k])
			buf.WriteString(",")
		}
		buf.FixSymbol()
		buf.WriteString("}")
		buf.WriteString(",")
	}

	if !x.IsEmptyFlt32Map() {
		buf.WriteString("\"flt32Map\"")
		buf.WriteString(":")
		buf.WriteString("{")
		for k, _ := range x.Flt32Map {
			buf.WriteString("\"" + k + "\"")
			buf.WriteString(":")
			buf.WriteFloat32(x.Flt32Map[k])
			buf.WriteString(",")
		}
		buf.FixSymbol()
		buf.WriteString("}")
		buf.WriteString(",")
	}

	if !x.IsEmptyFlt64Map() {
		buf.WriteString("\"flt64Map\"")
		buf.WriteString(":")
		buf.WriteString("{")
		for k, _ := range x.Flt64Map {
			buf.WriteString("\"" + k + "\"")
			buf.WriteString(":")
			buf.WriteFloat64(x.Flt64Map[k])
			buf.WriteString(",")
		}
		buf.FixSymbol()
		buf.WriteString("}")
		buf.WriteString(",")
	}

	if !x.IsEmptyBytsMap() {
		buf.WriteString("\"bytsMap\"")
		buf.WriteString(":")
		buf.WriteString("{")
		for k, _ := range x.BytsMap {
			buf.WriteString("\"" + k + "\"")
			buf.WriteString(":")
			buf.WriteBytes(x.BytsMap[k])
			buf.WriteString(",")
		}
		buf.FixSymbol()
		buf.WriteString("}")
		buf.WriteString(",")
	}

	if x.TestOneof != nil {
		if _, ok := x.GetTestOneof().(*Msg_OneofBol); ok {
			buf.WriteString("\"oneofBol\"")
			buf.WriteString(":")
			buf.WriteBool(x.GetOneofBol())
			buf.WriteString(",")
		}

	}

	buf.FixSymbol()
	buf.WriteString("}")
}

func (x *Msg) FastUnmarshal(p *jsonparser.Parser) {
	if x == nil {
		panic("type Msg is nil")
	}
	p.Symbol('{')
	for !p.IsSymbol('}') {
		key := p.Str()
		p.AssertSymbol(':')
		switch key {
		case "bol":
			x.Bol = p.Bol()

		case "str":
			x.Str = p.Str()

		case "in32":
			x.In32 = p.Int32()

		case "in64":
			x.In64 = p.Int64()

		case "uin32":
			x.Uin32 = p.Uint32()

		case "uin64":
			x.Uin64 = p.Uint64()

		case "flt32":
			x.Flt32 = p.Float32()

		case "flt64":
			x.Flt64 = p.Float64()

		case "byts":
			x.Byts = p.Bytes()

		case "bolArr":
			p.Symbol('[')
			arr := make([]bool, 0)
			for !p.IsSymbol(']') {
				arr = append(arr, p.Bol())
				p.AssertSymbol(',')
			}
			p.AssertSymbol(',')
			p.Symbol(']')
			x.BolArr = arr

		case "strArr":
			p.Symbol('[')
			arr := make([]string, 0)
			for !p.IsSymbol(']') {
				arr = append(arr, p.Str())
				p.AssertSymbol(',')
			}
			p.AssertSymbol(',')
			p.Symbol(']')
			x.StrArr = arr

		case "in32Arr":
			p.Symbol('[')
			arr := make([]int32, 0)
			for !p.IsSymbol(']') {
				arr = append(arr, p.Int32())
				p.AssertSymbol(',')
			}
			p.AssertSymbol(',')
			p.Symbol(']')
			x.In32Arr = arr

		case "in64Arr":
			p.Symbol('[')
			arr := make([]int64, 0)
			for !p.IsSymbol(']') {
				arr = append(arr, p.Int64())
				p.AssertSymbol(',')
			}
			p.AssertSymbol(',')
			p.Symbol(']')
			x.In64Arr = arr

		case "uin32Arr":
			p.Symbol('[')
			arr := make([]uint32, 0)
			for !p.IsSymbol(']') {
				arr = append(arr, p.Uint32())
				p.AssertSymbol(',')
			}
			p.AssertSymbol(',')
			p.Symbol(']')
			x.Uin32Arr = arr

		case "uin64Arr":
			p.Symbol('[')
			arr := make([]uint64, 0)
			for !p.IsSymbol(']') {
				arr = append(arr, p.Uint64())
				p.AssertSymbol(',')
			}
			p.AssertSymbol(',')
			p.Symbol(']')
			x.Uin64Arr = arr

		case "flt32Arr":
			p.Symbol('[')
			arr := make([]float32, 0)
			for !p.IsSymbol(']') {
				arr = append(arr, p.Float32())
				p.AssertSymbol(',')
			}
			p.AssertSymbol(',')
			p.Symbol(']')
			x.Flt32Arr = arr

		case "flt64Arr":
			p.Symbol('[')
			arr := make([]float64, 0)
			for !p.IsSymbol(']') {
				arr = append(arr, p.Float64())
				p.AssertSymbol(',')
			}
			p.AssertSymbol(',')
			p.Symbol(']')
			x.Flt64Arr = arr

		case "bytsArr":
			p.Symbol('[')
			arr := make([][]byte, 0)
			for !p.IsSymbol(']') {
				arr = append(arr, p.Bytes())
				p.AssertSymbol(',')
			}
			p.AssertSymbol(',')
			p.Symbol(']')
			x.BytsArr = arr

		case "bolMap":
			p.Symbol('{')
			m := make(map[string]bool)
			for !p.IsSymbol('}') {
				key := p.Str()
				p.AssertSymbol(':')
				m[key] = p.Bol()
				p.AssertSymbol(',')
			}
			p.AssertSymbol(',')
			p.Symbol('}')
			x.BolMap = m

		case "stringMap":
			p.Symbol('{')
			m := make(map[string]string)
			for !p.IsSymbol('}') {
				key := p.Str()
				p.AssertSymbol(':')
				m[key] = p.Str()
				p.AssertSymbol(',')
			}
			p.AssertSymbol(',')
			p.Symbol('}')
			x.StringMap = m

		case "in32Map":
			p.Symbol('{')
			m := make(map[string]int32)
			for !p.IsSymbol('}') {
				key := p.Str()
				p.AssertSymbol(':')
				m[key] = p.Int32()
				p.AssertSymbol(',')
			}
			p.AssertSymbol(',')
			p.Symbol('}')
			x.In32Map = m

		case "in64Map":
			p.Symbol('{')
			m := make(map[string]int64)
			for !p.IsSymbol('}') {
				key := p.Str()
				p.AssertSymbol(':')
				m[key] = p.Int64()
				p.AssertSymbol(',')
			}
			p.AssertSymbol(',')
			p.Symbol('}')
			x.In64Map = m

		case "uin32Map":
			p.Symbol('{')
			m := make(map[string]uint32)
			for !p.IsSymbol('}') {
				key := p.Str()
				p.AssertSymbol(':')
				m[key] = p.Uint32()
				p.AssertSymbol(',')
			}
			p.AssertSymbol(',')
			p.Symbol('}')
			x.Uin32Map = m

		case "uin64Map":
			p.Symbol('{')
			m := make(map[string]uint64)
			for !p.IsSymbol('}') {
				key := p.Str()
				p.AssertSymbol(':')
				m[key] = p.Uint64()
				p.AssertSymbol(',')
			}
			p.AssertSymbol(',')
			p.Symbol('}')
			x.Uin64Map = m

		case "flt32Map":
			p.Symbol('{')
			m := make(map[string]float32)
			for !p.IsSymbol('}') {
				key := p.Str()
				p.AssertSymbol(':')
				m[key] = p.Float32()
				p.AssertSymbol(',')
			}
			p.AssertSymbol(',')
			p.Symbol('}')
			x.Flt32Map = m

		case "flt64Map":
			p.Symbol('{')
			m := make(map[string]float64)
			for !p.IsSymbol('}') {
				key := p.Str()
				p.AssertSymbol(':')
				m[key] = p.Float64()
				p.AssertSymbol(',')
			}
			p.AssertSymbol(',')
			p.Symbol('}')
			x.Flt64Map = m

		case "bytsMap":
			p.Symbol('{')
			m := make(map[string][]byte)
			for !p.IsSymbol('}') {
				key := p.Str()
				p.AssertSymbol(':')
				m[key] = p.Bytes()
				p.AssertSymbol(',')
			}
			p.AssertSymbol(',')
			p.Symbol('}')
			x.BytsMap = m

		case "oneofBol":
			tmp := &Msg_OneofBol{}
			tmp.OneofBol = p.Bol()
			x.TestOneof = tmp
		default:
			p.PassParse()
		}
		p.AssertSymbol(',')
	}
	p.AssertSymbol(',')
	p.Symbol('}')
}

var MsgPool sync.Pool

func MsgNew() *Msg {
	if v := MsgPool.Get(); v != nil {
		return v.(*Msg)
	}
	return &Msg{}
}
func (x *Msg) Destructor() {
	if x == nil {
		panic("type Msg is nil")
	}
	x.Bol = false
	x.Str = ""
	x.In32 = 0
	x.In64 = 0
	x.Uin32 = 0
	x.Uin64 = 0
	x.Flt32 = 0
	x.Flt64 = 0
	x.Byts = nil
	x.BolArr = nil
	x.StrArr = nil
	x.In32Arr = nil
	x.In64Arr = nil
	x.Uin32Arr = nil
	x.Uin64Arr = nil
	x.Flt32Arr = nil
	x.Flt64Arr = nil
	x.BytsArr = nil
	x.BolMap = nil
	x.StringMap = nil
	x.In32Map = nil
	x.In64Map = nil
	x.Uin32Map = nil
	x.Uin64Map = nil
	x.Flt32Map = nil
	x.Flt64Map = nil
	x.BytsMap = nil
	if x.TestOneof != nil {
		x.TestOneof = nil
	}
	MsgPool.Put(x)
}

func (x *Msg) IsEmptyBol() bool {
	return x.GetBol() == false
}

func (x *Msg) IsEmptyStr() bool {
	return x.GetStr() == ""
}

func (x *Msg) IsEmptyIn32() bool {
	return x.GetIn32() == 0
}

func (x *Msg) IsEmptyIn64() bool {
	return x.GetIn64() == 0
}

func (x *Msg) IsEmptyUin32() bool {
	return x.GetUin32() == 0
}

func (x *Msg) IsEmptyUin64() bool {
	return x.GetUin64() == 0
}

func (x *Msg) IsEmptyFlt32() bool {
	return x.GetFlt32() == 0
}

func (x *Msg) IsEmptyFlt64() bool {
	return x.GetFlt64() == 0
}

func (x *Msg) IsEmptyByts() bool {
	return x.GetByts() == nil
}

func (x *Msg) IsEmptyBolArr() bool {
	return x.GetBolArr() == nil
}

func (x *Msg) IsEmptyStrArr() bool {
	return x.GetStrArr() == nil
}

func (x *Msg) IsEmptyIn32Arr() bool {
	return x.GetIn32Arr() == nil
}

func (x *Msg) IsEmptyIn64Arr() bool {
	return x.GetIn64Arr() == nil
}

func (x *Msg) IsEmptyUin32Arr() bool {
	return x.GetUin32Arr() == nil
}

func (x *Msg) IsEmptyUin64Arr() bool {
	return x.GetUin64Arr() == nil
}

func (x *Msg) IsEmptyFlt32Arr() bool {
	return x.GetFlt32Arr() == nil
}

func (x *Msg) IsEmptyFlt64Arr() bool {
	return x.GetFlt64Arr() == nil
}

func (x *Msg) IsEmptyBytsArr() bool {
	return x.GetBytsArr() == nil
}

func (x *Msg) IsEmptyBolMap() bool {
	return x.GetBolMap() == nil
}

func (x *Msg) IsEmptyStringMap() bool {
	return x.GetStringMap() == nil
}

func (x *Msg) IsEmptyIn32Map() bool {
	return x.GetIn32Map() == nil
}

func (x *Msg) IsEmptyIn64Map() bool {
	return x.GetIn64Map() == nil
}

func (x *Msg) IsEmptyUin32Map() bool {
	return x.GetUin32Map() == nil
}

func (x *Msg) IsEmptyUin64Map() bool {
	return x.GetUin64Map() == nil
}

func (x *Msg) IsEmptyFlt32Map() bool {
	return x.GetFlt32Map() == nil
}

func (x *Msg) IsEmptyFlt64Map() bool {
	return x.GetFlt64Map() == nil
}

func (x *Msg) IsEmptyBytsMap() bool {
	return x.GetBytsMap() == nil
}

func (x *Example) FastMarshal(buf *buffer.Buffer) {
	if x == nil {
		buf.WriteString("{}")
	}
	buf.WriteString("{")
	if !x.IsEmptyBol() {
		buf.WriteString("\"bol\"")
		buf.WriteString(":")
		buf.WriteBool(x.GetBol())
		buf.WriteString(",")
	}

	if !x.IsEmptyStr() {
		buf.WriteString("\"str\"")
		buf.WriteString(":")
		buf.WriteString("\"" + x.GetStr() + "\"")
		buf.WriteString(",")
	}

	if !x.IsEmptyIn32() {
		buf.WriteString("\"in32\"")
		buf.WriteString(":")
		buf.WriteInt32(x.GetIn32())
		buf.WriteString(",")
	}

	if !x.IsEmptyIn64() {
		buf.WriteString("\"in64\"")
		buf.WriteString(":")
		buf.WriteInt64(x.GetIn64())
		buf.WriteString(",")
	}

	if !x.IsEmptyUin32() {
		buf.WriteString("\"uin32\"")
		buf.WriteString(":")
		buf.WriteUint32(x.GetUin32())
		buf.WriteString(",")
	}

	if !x.IsEmptyUin64() {
		buf.WriteString("\"uin64\"")
		buf.WriteString(":")
		buf.WriteUint64(x.GetUin64())
		buf.WriteString(",")
	}

	if !x.IsEmptyFlt32() {
		buf.WriteString("\"flt32\"")
		buf.WriteString(":")
		buf.WriteFloat32(x.GetFlt32())
		buf.WriteString(",")
	}

	if !x.IsEmptyFlt64() {
		buf.WriteString("\"flt64\"")
		buf.WriteString(":")
		buf.WriteFloat64(x.GetFlt64())
		buf.WriteString(",")
	}

	if !x.IsEmptyByts() {
		buf.WriteString("\"byts\"")
		buf.WriteString(":")
		buf.WriteBytes(x.GetByts())
		buf.WriteString(",")
	}

	if !x.IsEmptyTyp() {
		buf.WriteString("\"typ\"")
		buf.WriteString(":")
		buf.WriteString("\"" + x.GetTyp().String() + "\"")
		buf.WriteString(",")
	}

	if !x.IsEmptyMsg() {
		buf.WriteString("\"msg\"")
		buf.WriteString(":")
		x.GetMsg().FastMarshal(buf)
		buf.WriteString(",")
	}

	if !x.IsEmptyBolArr() {
		buf.WriteString("\"bolArr\"")
		buf.WriteString(":")
		buf.WriteString("[")
		for i, _ := range x.BolArr {
			buf.WriteBool(x.BolArr[i])
			buf.WriteString(",")
		}
		buf.FixSymbol()
		buf.WriteString("]")
		buf.WriteString(",")
	}

	if !x.IsEmptyStrArr() {
		buf.WriteString("\"strArr\"")
		buf.WriteString(":")
		buf.WriteString("[")
		for i, _ := range x.StrArr {
			buf.WriteString("\"" + x.StrArr[i] + "\"")
			buf.WriteString(",")
		}
		buf.FixSymbol()
		buf.WriteString("]")
		buf.WriteString(",")
	}

	if !x.IsEmptyIn32Arr() {
		buf.WriteString("\"in32Arr\"")
		buf.WriteString(":")
		buf.WriteString("[")
		for i, _ := range x.In32Arr {
			buf.WriteInt32(x.In32Arr[i])
			buf.WriteString(",")
		}
		buf.FixSymbol()
		buf.WriteString("]")
		buf.WriteString(",")
	}

	if !x.IsEmptyIn64Arr() {
		buf.WriteString("\"in64Arr\"")
		buf.WriteString(":")
		buf.WriteString("[")
		for i, _ := range x.In64Arr {
			buf.WriteInt64(x.In64Arr[i])
			buf.WriteString(",")
		}
		buf.FixSymbol()
		buf.WriteString("]")
		buf.WriteString(",")
	}

	if !x.IsEmptyUin32Arr() {
		buf.WriteString("\"uin32Arr\"")
		buf.WriteString(":")
		buf.WriteString("[")
		for i, _ := range x.Uin32Arr {
			buf.WriteUint32(x.Uin32Arr[i])
			buf.WriteString(",")
		}
		buf.FixSymbol()
		buf.WriteString("]")
		buf.WriteString(",")
	}

	if !x.IsEmptyUin64Arr() {
		buf.WriteString("\"uin64Arr\"")
		buf.WriteString(":")
		buf.WriteString("[")
		for i, _ := range x.Uin64Arr {
			buf.WriteUint64(x.Uin64Arr[i])
			buf.WriteString(",")
		}
		buf.FixSymbol()
		buf.WriteString("]")
		buf.WriteString(",")
	}

	if !x.IsEmptyFlt32Arr() {
		buf.WriteString("\"flt32Arr\"")
		buf.WriteString(":")
		buf.WriteString("[")
		for i, _ := range x.Flt32Arr {
			buf.WriteFloat32(x.Flt32Arr[i])
			buf.WriteString(",")
		}
		buf.FixSymbol()
		buf.WriteString("]")
		buf.WriteString(",")
	}

	if !x.IsEmptyFlt64Arr() {
		buf.WriteString("\"flt64Arr\"")
		buf.WriteString(":")
		buf.WriteString("[")
		for i, _ := range x.Flt64Arr {
			buf.WriteFloat64(x.Flt64Arr[i])
			buf.WriteString(",")
		}
		buf.FixSymbol()
		buf.WriteString("]")
		buf.WriteString(",")
	}

	if !x.IsEmptyBytsArr() {
		buf.WriteString("\"bytsArr\"")
		buf.WriteString(":")
		buf.WriteString("[")
		for i, _ := range x.BytsArr {
			buf.WriteBytes(x.BytsArr[i])
			buf.WriteString(",")
		}
		buf.FixSymbol()
		buf.WriteString("]")
		buf.WriteString(",")
	}

	if !x.IsEmptyTypArr() {
		buf.WriteString("\"typArr\"")
		buf.WriteString(":")
		buf.WriteString("[")
		for i, _ := range x.TypArr {
			buf.WriteString("\"" + x.TypArr[i].String() + "\"")
			buf.WriteString(",")
		}
		buf.FixSymbol()
		buf.WriteString("]")
		buf.WriteString(",")
	}

	if !x.IsEmptyMsgArr() {
		buf.WriteString("\"msgArr\"")
		buf.WriteString(":")
		buf.WriteString("[")
		for i, _ := range x.MsgArr {
			x.MsgArr[i].FastMarshal(buf)
			buf.WriteString(",")
		}
		buf.FixSymbol()
		buf.WriteString("]")
		buf.WriteString(",")
	}

	if !x.IsEmptyBolMap() {
		buf.WriteString("\"bolMap\"")
		buf.WriteString(":")
		buf.WriteString("{")
		for k, _ := range x.BolMap {
			buf.WriteString("\"" + k + "\"")
			buf.WriteString(":")
			buf.WriteBool(x.BolMap[k])
			buf.WriteString(",")
		}
		buf.FixSymbol()
		buf.WriteString("}")
		buf.WriteString(",")
	}

	if !x.IsEmptyStringMap() {
		buf.WriteString("\"stringMap\"")
		buf.WriteString(":")
		buf.WriteString("{")
		for k, _ := range x.StringMap {
			buf.WriteString("\"" + k + "\"")
			buf.WriteString(":")
			buf.WriteString("\"" + x.StringMap[k] + "\"")
			buf.WriteString(",")
		}
		buf.FixSymbol()
		buf.WriteString("}")
		buf.WriteString(",")
	}

	if !x.IsEmptyIn32Map() {
		buf.WriteString("\"in32Map\"")
		buf.WriteString(":")
		buf.WriteString("{")
		for k, _ := range x.In32Map {
			buf.WriteString("\"" + k + "\"")
			buf.WriteString(":")
			buf.WriteInt32(x.In32Map[k])
			buf.WriteString(",")
		}
		buf.FixSymbol()
		buf.WriteString("}")
		buf.WriteString(",")
	}

	if !x.IsEmptyIn64Map() {
		buf.WriteString("\"in64Map\"")
		buf.WriteString(":")
		buf.WriteString("{")
		for k, _ := range x.In64Map {
			buf.WriteString("\"" + k + "\"")
			buf.WriteString(":")
			buf.WriteInt64(x.In64Map[k])
			buf.WriteString(",")
		}
		buf.FixSymbol()
		buf.WriteString("}")
		buf.WriteString(",")
	}

	if !x.IsEmptyUin32Map() {
		buf.WriteString("\"uin32Map\"")
		buf.WriteString(":")
		buf.WriteString("{")
		for k, _ := range x.Uin32Map {
			buf.WriteString("\"" + k + "\"")
			buf.WriteString(":")
			buf.WriteUint32(x.Uin32Map[k])
			buf.WriteString(",")
		}
		buf.FixSymbol()
		buf.WriteString("}")
		buf.WriteString(",")
	}

	if !x.IsEmptyUin64Map() {
		buf.WriteString("\"uin64Map\"")
		buf.WriteString(":")
		buf.WriteString("{")
		for k, _ := range x.Uin64Map {
			buf.WriteString("\"" + k + "\"")
			buf.WriteString(":")
			buf.WriteUint64(x.Uin64Map[k])
			buf.WriteString(",")
		}
		buf.FixSymbol()
		buf.WriteString("}")
		buf.WriteString(",")
	}

	if !x.IsEmptyFlt32Map() {
		buf.WriteString("\"flt32Map\"")
		buf.WriteString(":")
		buf.WriteString("{")
		for k, _ := range x.Flt32Map {
			buf.WriteString("\"" + k + "\"")
			buf.WriteString(":")
			buf.WriteFloat32(x.Flt32Map[k])
			buf.WriteString(",")
		}
		buf.FixSymbol()
		buf.WriteString("}")
		buf.WriteString(",")
	}

	if !x.IsEmptyFlt64Map() {
		buf.WriteString("\"flt64Map\"")
		buf.WriteString(":")
		buf.WriteString("{")
		for k, _ := range x.Flt64Map {
			buf.WriteString("\"" + k + "\"")
			buf.WriteString(":")
			buf.WriteFloat64(x.Flt64Map[k])
			buf.WriteString(",")
		}
		buf.FixSymbol()
		buf.WriteString("}")
		buf.WriteString(",")
	}

	if !x.IsEmptyBytsMap() {
		buf.WriteString("\"bytsMap\"")
		buf.WriteString(":")
		buf.WriteString("{")
		for k, _ := range x.BytsMap {
			buf.WriteString("\"" + k + "\"")
			buf.WriteString(":")
			buf.WriteBytes(x.BytsMap[k])
			buf.WriteString(",")
		}
		buf.FixSymbol()
		buf.WriteString("}")
		buf.WriteString(",")
	}

	if !x.IsEmptyTypMap() {
		buf.WriteString("\"typMap\"")
		buf.WriteString(":")
		buf.WriteString("{")
		for k, _ := range x.TypMap {
			buf.WriteString("\"" + k + "\"")
			buf.WriteString(":")
			buf.WriteString("\"" + x.TypMap[k].String() + "\"")
			buf.WriteString(",")
		}
		buf.FixSymbol()
		buf.WriteString("}")
		buf.WriteString(",")
	}

	if !x.IsEmptyMsgMap() {
		buf.WriteString("\"msgMap\"")
		buf.WriteString(":")
		buf.WriteString("{")
		for k, _ := range x.MsgMap {
			buf.WriteString("\"" + k + "\"")
			buf.WriteString(":")
			x.MsgMap[k].FastMarshal(buf)
			buf.WriteString(",")
		}
		buf.FixSymbol()
		buf.WriteString("}")
		buf.WriteString(",")
	}

	if !x.IsEmptyNestedTyp() {
		buf.WriteString("\"nestedTyp\"")
		buf.WriteString(":")
		buf.WriteString("\"" + x.GetNestedTyp().String() + "\"")
		buf.WriteString(",")
	}

	if !x.IsEmptyNestedMsg() {
		buf.WriteString("\"nestedMsg\"")
		buf.WriteString(":")
		x.GetNestedMsg().FastMarshal(buf)
		buf.WriteString(",")
	}

	if !x.IsEmptyNestedTypMap() {
		buf.WriteString("\"nestedTypMap\"")
		buf.WriteString(":")
		buf.WriteString("{")
		for k, _ := range x.NestedTypMap {
			buf.WriteString("\"" + k + "\"")
			buf.WriteString(":")
			buf.WriteString("\"" + x.NestedTypMap[k].String() + "\"")
			buf.WriteString(",")
		}
		buf.FixSymbol()
		buf.WriteString("}")
		buf.WriteString(",")
	}

	if !x.IsEmptyNestedMsgMap() {
		buf.WriteString("\"nestedMsgMap\"")
		buf.WriteString(":")
		buf.WriteString("{")
		for k, _ := range x.NestedMsgMap {
			buf.WriteString("\"" + k + "\"")
			buf.WriteString(":")
			x.NestedMsgMap[k].FastMarshal(buf)
			buf.WriteString(",")
		}
		buf.FixSymbol()
		buf.WriteString("}")
		buf.WriteString(",")
	}

	if x.TestOneof != nil {
		if _, ok := x.GetTestOneof().(*Example_OneofBol); ok {
			buf.WriteString("\"oneofBol\"")
			buf.WriteString(":")
			buf.WriteBool(x.GetOneofBol())
			buf.WriteString(",")

		} else if _, ok := x.GetTestOneof().(*Example_OneofStr); ok {
			buf.WriteString("\"oneofStr\"")
			buf.WriteString(":")
			buf.WriteString("\"" + x.GetOneofStr() + "\"")
			buf.WriteString(",")

		} else if _, ok := x.GetTestOneof().(*Example_OneofIn32); ok {
			buf.WriteString("\"oneofIn32\"")
			buf.WriteString(":")
			buf.WriteInt32(x.GetOneofIn32())
			buf.WriteString(",")

		} else if _, ok := x.GetTestOneof().(*Example_OneofIn64); ok {
			buf.WriteString("\"oneofIn64\"")
			buf.WriteString(":")
			buf.WriteInt64(x.GetOneofIn64())
			buf.WriteString(",")

		} else if _, ok := x.GetTestOneof().(*Example_OneofUin32); ok {
			buf.WriteString("\"oneofUin32\"")
			buf.WriteString(":")
			buf.WriteUint32(x.GetOneofUin32())
			buf.WriteString(",")

		} else if _, ok := x.GetTestOneof().(*Example_OneofUin64); ok {
			buf.WriteString("\"oneofUin64\"")
			buf.WriteString(":")
			buf.WriteUint64(x.GetOneofUin64())
			buf.WriteString(",")

		} else if _, ok := x.GetTestOneof().(*Example_OneofFlt32); ok {
			buf.WriteString("\"oneofFlt32\"")
			buf.WriteString(":")
			buf.WriteFloat32(x.GetOneofFlt32())
			buf.WriteString(",")

		} else if _, ok := x.GetTestOneof().(*Example_OneofFlt64); ok {
			buf.WriteString("\"oneofFlt64\"")
			buf.WriteString(":")
			buf.WriteFloat64(x.GetOneofFlt64())
			buf.WriteString(",")

		} else if _, ok := x.GetTestOneof().(*Example_OneofByts); ok {
			buf.WriteString("\"oneofByts\"")
			buf.WriteString(":")
			buf.WriteBytes(x.GetOneofByts())
			buf.WriteString(",")

		} else if _, ok := x.GetTestOneof().(*Example_OneofMsg); ok {
			buf.WriteString("\"oneofMsg\"")
			buf.WriteString(":")
			x.GetOneofMsg().FastMarshal(buf)
			buf.WriteString(",")
		}

	}

	buf.FixSymbol()
	buf.WriteString("}")
}

func (x *Example) FastUnmarshal(p *jsonparser.Parser) {
	if x == nil {
		panic("type Example is nil")
	}
	p.Symbol('{')
	for !p.IsSymbol('}') {
		key := p.Str()
		p.AssertSymbol(':')
		switch key {
		case "bol":
			x.Bol = p.Bol()

		case "str":
			x.Str = p.Str()

		case "in32":
			x.In32 = p.Int32()

		case "in64":
			x.In64 = p.Int64()

		case "uin32":
			x.Uin32 = p.Uint32()

		case "uin64":
			x.Uin64 = p.Uint64()

		case "flt32":
			x.Flt32 = p.Float32()

		case "flt64":
			x.Flt64 = p.Float64()

		case "byts":
			x.Byts = p.Bytes()

		case "typ":
			t, s, i := p.Enum()
			if t == jsonparser.EnumNumber {
				x.Typ.Set(i)
			} else {
				x.Typ.SetByStr(s)
			}

		case "msg":
			x.Msg = MsgNew()
			x.Msg.FastUnmarshal(p)

		case "bolArr":
			p.Symbol('[')
			arr := make([]bool, 0)
			for !p.IsSymbol(']') {
				arr = append(arr, p.Bol())
				p.AssertSymbol(',')
			}
			p.AssertSymbol(',')
			p.Symbol(']')
			x.BolArr = arr

		case "strArr":
			p.Symbol('[')
			arr := make([]string, 0)
			for !p.IsSymbol(']') {
				arr = append(arr, p.Str())
				p.AssertSymbol(',')
			}
			p.AssertSymbol(',')
			p.Symbol(']')
			x.StrArr = arr

		case "in32Arr":
			p.Symbol('[')
			arr := make([]int32, 0)
			for !p.IsSymbol(']') {
				arr = append(arr, p.Int32())
				p.AssertSymbol(',')
			}
			p.AssertSymbol(',')
			p.Symbol(']')
			x.In32Arr = arr

		case "in64Arr":
			p.Symbol('[')
			arr := make([]int64, 0)
			for !p.IsSymbol(']') {
				arr = append(arr, p.Int64())
				p.AssertSymbol(',')
			}
			p.AssertSymbol(',')
			p.Symbol(']')
			x.In64Arr = arr

		case "uin32Arr":
			p.Symbol('[')
			arr := make([]uint32, 0)
			for !p.IsSymbol(']') {
				arr = append(arr, p.Uint32())
				p.AssertSymbol(',')
			}
			p.AssertSymbol(',')
			p.Symbol(']')
			x.Uin32Arr = arr

		case "uin64Arr":
			p.Symbol('[')
			arr := make([]uint64, 0)
			for !p.IsSymbol(']') {
				arr = append(arr, p.Uint64())
				p.AssertSymbol(',')
			}
			p.AssertSymbol(',')
			p.Symbol(']')
			x.Uin64Arr = arr

		case "flt32Arr":
			p.Symbol('[')
			arr := make([]float32, 0)
			for !p.IsSymbol(']') {
				arr = append(arr, p.Float32())
				p.AssertSymbol(',')
			}
			p.AssertSymbol(',')
			p.Symbol(']')
			x.Flt32Arr = arr

		case "flt64Arr":
			p.Symbol('[')
			arr := make([]float64, 0)
			for !p.IsSymbol(']') {
				arr = append(arr, p.Float64())
				p.AssertSymbol(',')
			}
			p.AssertSymbol(',')
			p.Symbol(']')
			x.Flt64Arr = arr

		case "bytsArr":
			p.Symbol('[')
			arr := make([][]byte, 0)
			for !p.IsSymbol(']') {
				arr = append(arr, p.Bytes())
				p.AssertSymbol(',')
			}
			p.AssertSymbol(',')
			p.Symbol(']')
			x.BytsArr = arr

		case "typArr":
			p.Symbol('[')
			arr := make([]Typ, 0)
			for !p.IsSymbol(']') {
				var e Typ
				t, s, i := p.Enum()
				if t == jsonparser.EnumNumber {
					e = e.Get(i)
				} else {
					e = e.GetByStr(s)
				}
				arr = append(arr, e)
				p.AssertSymbol(',')
			}
			p.AssertSymbol(',')
			p.Symbol(']')
			x.TypArr = arr

		case "msgArr":
			p.Symbol('[')
			arr := make([]*Msg, 0)
			for !p.IsSymbol(']') {
				tmp := MsgNew()
				tmp.FastUnmarshal(p)
				arr = append(arr, tmp)
				p.AssertSymbol(',')
			}
			p.AssertSymbol(',')
			p.Symbol(']')
			x.MsgArr = arr

		case "bolMap":
			p.Symbol('{')
			m := make(map[string]bool)
			for !p.IsSymbol('}') {
				key := p.Str()
				p.AssertSymbol(':')
				m[key] = p.Bol()
				p.AssertSymbol(',')
			}
			p.AssertSymbol(',')
			p.Symbol('}')
			x.BolMap = m

		case "stringMap":
			p.Symbol('{')
			m := make(map[string]string)
			for !p.IsSymbol('}') {
				key := p.Str()
				p.AssertSymbol(':')
				m[key] = p.Str()
				p.AssertSymbol(',')
			}
			p.AssertSymbol(',')
			p.Symbol('}')
			x.StringMap = m

		case "in32Map":
			p.Symbol('{')
			m := make(map[string]int32)
			for !p.IsSymbol('}') {
				key := p.Str()
				p.AssertSymbol(':')
				m[key] = p.Int32()
				p.AssertSymbol(',')
			}
			p.AssertSymbol(',')
			p.Symbol('}')
			x.In32Map = m

		case "in64Map":
			p.Symbol('{')
			m := make(map[string]int64)
			for !p.IsSymbol('}') {
				key := p.Str()
				p.AssertSymbol(':')
				m[key] = p.Int64()
				p.AssertSymbol(',')
			}
			p.AssertSymbol(',')
			p.Symbol('}')
			x.In64Map = m

		case "uin32Map":
			p.Symbol('{')
			m := make(map[string]uint32)
			for !p.IsSymbol('}') {
				key := p.Str()
				p.AssertSymbol(':')
				m[key] = p.Uint32()
				p.AssertSymbol(',')
			}
			p.AssertSymbol(',')
			p.Symbol('}')
			x.Uin32Map = m

		case "uin64Map":
			p.Symbol('{')
			m := make(map[string]uint64)
			for !p.IsSymbol('}') {
				key := p.Str()
				p.AssertSymbol(':')
				m[key] = p.Uint64()
				p.AssertSymbol(',')
			}
			p.AssertSymbol(',')
			p.Symbol('}')
			x.Uin64Map = m

		case "flt32Map":
			p.Symbol('{')
			m := make(map[string]float32)
			for !p.IsSymbol('}') {
				key := p.Str()
				p.AssertSymbol(':')
				m[key] = p.Float32()
				p.AssertSymbol(',')
			}
			p.AssertSymbol(',')
			p.Symbol('}')
			x.Flt32Map = m

		case "flt64Map":
			p.Symbol('{')
			m := make(map[string]float64)
			for !p.IsSymbol('}') {
				key := p.Str()
				p.AssertSymbol(':')
				m[key] = p.Float64()
				p.AssertSymbol(',')
			}
			p.AssertSymbol(',')
			p.Symbol('}')
			x.Flt64Map = m

		case "bytsMap":
			p.Symbol('{')
			m := make(map[string][]byte)
			for !p.IsSymbol('}') {
				key := p.Str()
				p.AssertSymbol(':')
				m[key] = p.Bytes()
				p.AssertSymbol(',')
			}
			p.AssertSymbol(',')
			p.Symbol('}')
			x.BytsMap = m

		case "typMap":
			p.Symbol('{')
			m := make(map[string]Typ)
			for !p.IsSymbol('}') {
				key := p.Str()
				p.AssertSymbol(':')
				var e Typ
				t, s, i := p.Enum()
				if t == jsonparser.EnumNumber {
					e = e.Get(i)
				} else {
					e = e.GetByStr(s)
				}
				m[key] = e
				p.AssertSymbol(',')
			}
			p.AssertSymbol(',')
			p.Symbol('}')
			x.TypMap = m

		case "msgMap":
			p.Symbol('{')
			m := make(map[string]*Msg)
			for !p.IsSymbol('}') {
				key := p.Str()
				p.AssertSymbol(':')
				tmp := MsgNew()
				tmp.FastUnmarshal(p)
				m[key] = tmp
				p.AssertSymbol(',')
			}
			p.AssertSymbol(',')
			p.Symbol('}')
			x.MsgMap = m

		case "nestedTyp":
			t, s, i := p.Enum()
			if t == jsonparser.EnumNumber {
				x.NestedTyp.Set(i)
			} else {
				x.NestedTyp.SetByStr(s)
			}

		case "nestedMsg":
			x.NestedMsg = Example_NestedMsgNew()
			x.NestedMsg.FastUnmarshal(p)

		case "nestedTypMap":
			p.Symbol('{')
			m := make(map[string]Example_NestedTyp)
			for !p.IsSymbol('}') {
				key := p.Str()
				p.AssertSymbol(':')
				var e Example_NestedTyp
				t, s, i := p.Enum()
				if t == jsonparser.EnumNumber {
					e = e.Get(i)
				} else {
					e = e.GetByStr(s)
				}
				m[key] = e
				p.AssertSymbol(',')
			}
			p.AssertSymbol(',')
			p.Symbol('}')
			x.NestedTypMap = m

		case "nestedMsgMap":
			p.Symbol('{')
			m := make(map[string]*Example_NestedMsg)
			for !p.IsSymbol('}') {
				key := p.Str()
				p.AssertSymbol(':')
				tmp := Example_NestedMsgNew()
				tmp.FastUnmarshal(p)
				m[key] = tmp
				p.AssertSymbol(',')
			}
			p.AssertSymbol(',')
			p.Symbol('}')
			x.NestedMsgMap = m

		case "oneofBol":
			tmp := &Example_OneofBol{}
			tmp.OneofBol = p.Bol()
			x.TestOneof = tmp
		case "oneofStr":
			tmp := &Example_OneofStr{}
			tmp.OneofStr = p.Str()
			x.TestOneof = tmp
		case "oneofIn32":
			tmp := &Example_OneofIn32{}
			tmp.OneofIn32 = p.Int32()
			x.TestOneof = tmp
		case "oneofIn64":
			tmp := &Example_OneofIn64{}
			tmp.OneofIn64 = p.Int64()
			x.TestOneof = tmp
		case "oneofUin32":
			tmp := &Example_OneofUin32{}
			tmp.OneofUin32 = p.Uint32()
			x.TestOneof = tmp
		case "oneofUin64":
			tmp := &Example_OneofUin64{}
			tmp.OneofUin64 = p.Uint64()
			x.TestOneof = tmp
		case "oneofFlt32":
			tmp := &Example_OneofFlt32{}
			tmp.OneofFlt32 = p.Float32()
			x.TestOneof = tmp
		case "oneofFlt64":
			tmp := &Example_OneofFlt64{}
			tmp.OneofFlt64 = p.Float64()
			x.TestOneof = tmp
		case "oneofByts":
			tmp := &Example_OneofByts{}
			tmp.OneofByts = p.Bytes()
			x.TestOneof = tmp
		case "oneofMsg":
			tmp := &Example_OneofMsg{}
			tmp.OneofMsg = MsgNew()
			tmp.OneofMsg.FastUnmarshal(p)
			x.TestOneof = tmp
		default:
			p.PassParse()
		}
		p.AssertSymbol(',')
	}
	p.AssertSymbol(',')
	p.Symbol('}')
}

var ExamplePool sync.Pool

func ExampleNew() *Example {
	if v := ExamplePool.Get(); v != nil {
		return v.(*Example)
	}
	return &Example{}
}
func (x *Example) Destructor() {
	if x == nil {
		panic("type Example is nil")
	}
	x.Bol = false
	x.Str = ""
	x.In32 = 0
	x.In64 = 0
	x.Uin32 = 0
	x.Uin64 = 0
	x.Flt32 = 0
	x.Flt64 = 0
	x.Byts = nil
	x.Typ.Set(0)
	x.Msg.Destructor()
	x.Msg = nil
	x.BolArr = nil
	x.StrArr = nil
	x.In32Arr = nil
	x.In64Arr = nil
	x.Uin32Arr = nil
	x.Uin64Arr = nil
	x.Flt32Arr = nil
	x.Flt64Arr = nil
	x.BytsArr = nil
	x.TypArr = nil
	for i, _ := range x.MsgArr {
		x.MsgArr[i].Destructor()
	}
	x.MsgArr = nil
	x.BolMap = nil
	x.StringMap = nil
	x.In32Map = nil
	x.In64Map = nil
	x.Uin32Map = nil
	x.Uin64Map = nil
	x.Flt32Map = nil
	x.Flt64Map = nil
	x.BytsMap = nil
	x.TypMap = nil
	for i, _ := range x.MsgMap {
		x.MsgMap[i].Destructor()
	}
	x.MsgMap = nil
	x.NestedTyp.Set(0)
	x.NestedMsg.Destructor()
	x.NestedMsg = nil
	x.NestedTypMap = nil
	for i, _ := range x.NestedMsgMap {
		x.NestedMsgMap[i].Destructor()
	}
	x.NestedMsgMap = nil
	if x.TestOneof != nil {
		if _, ok := x.GetTestOneof().(*Example_OneofMsg); ok {
			x.GetOneofMsg().Destructor()
		}
		x.TestOneof = nil
	}
	ExamplePool.Put(x)
}

func (x *Example) IsEmptyBol() bool {
	return x.GetBol() == false
}

func (x *Example) IsEmptyStr() bool {
	return x.GetStr() == ""
}

func (x *Example) IsEmptyIn32() bool {
	return x.GetIn32() == 0
}

func (x *Example) IsEmptyIn64() bool {
	return x.GetIn64() == 0
}

func (x *Example) IsEmptyUin32() bool {
	return x.GetUin32() == 0
}

func (x *Example) IsEmptyUin64() bool {
	return x.GetUin64() == 0
}

func (x *Example) IsEmptyFlt32() bool {
	return x.GetFlt32() == 0
}

func (x *Example) IsEmptyFlt64() bool {
	return x.GetFlt64() == 0
}

func (x *Example) IsEmptyByts() bool {
	return x.GetByts() == nil
}

func (x *Example) IsEmptyTyp() bool {
	return int32(x.GetTyp()) == 0
}

func (x *Example) IsEmptyMsg() bool {
	return x.GetMsg() == nil
}

func (x *Example) IsEmptyBolArr() bool {
	return x.GetBolArr() == nil
}

func (x *Example) IsEmptyStrArr() bool {
	return x.GetStrArr() == nil
}

func (x *Example) IsEmptyIn32Arr() bool {
	return x.GetIn32Arr() == nil
}

func (x *Example) IsEmptyIn64Arr() bool {
	return x.GetIn64Arr() == nil
}

func (x *Example) IsEmptyUin32Arr() bool {
	return x.GetUin32Arr() == nil
}

func (x *Example) IsEmptyUin64Arr() bool {
	return x.GetUin64Arr() == nil
}

func (x *Example) IsEmptyFlt32Arr() bool {
	return x.GetFlt32Arr() == nil
}

func (x *Example) IsEmptyFlt64Arr() bool {
	return x.GetFlt64Arr() == nil
}

func (x *Example) IsEmptyBytsArr() bool {
	return x.GetBytsArr() == nil
}

func (x *Example) IsEmptyTypArr() bool {
	return x.GetTypArr() == nil
}

func (x *Example) IsEmptyMsgArr() bool {
	return x.GetMsgArr() == nil
}

func (x *Example) IsEmptyBolMap() bool {
	return x.GetBolMap() == nil
}

func (x *Example) IsEmptyStringMap() bool {
	return x.GetStringMap() == nil
}

func (x *Example) IsEmptyIn32Map() bool {
	return x.GetIn32Map() == nil
}

func (x *Example) IsEmptyIn64Map() bool {
	return x.GetIn64Map() == nil
}

func (x *Example) IsEmptyUin32Map() bool {
	return x.GetUin32Map() == nil
}

func (x *Example) IsEmptyUin64Map() bool {
	return x.GetUin64Map() == nil
}

func (x *Example) IsEmptyFlt32Map() bool {
	return x.GetFlt32Map() == nil
}

func (x *Example) IsEmptyFlt64Map() bool {
	return x.GetFlt64Map() == nil
}

func (x *Example) IsEmptyBytsMap() bool {
	return x.GetBytsMap() == nil
}

func (x *Example) IsEmptyTypMap() bool {
	return x.GetTypMap() == nil
}

func (x *Example) IsEmptyMsgMap() bool {
	return x.GetMsgMap() == nil
}

func (x *Example) IsEmptyNestedTyp() bool {
	return int32(x.GetNestedTyp()) == 0
}

func (x *Example) IsEmptyNestedMsg() bool {
	return x.GetNestedMsg() == nil
}

func (x *Example) IsEmptyNestedTypMap() bool {
	return x.GetNestedTypMap() == nil
}

func (x *Example) IsEmptyNestedMsgMap() bool {
	return x.GetNestedMsgMap() == nil
}

func (x *Example_NestedMsg) FastMarshal(buf *buffer.Buffer) {
	if x == nil {
		buf.WriteString("{}")
	}
	buf.WriteString("{")
	if !x.IsEmptyStr() {
		buf.WriteString("\"str\"")
		buf.WriteString(":")
		buf.WriteString("\"" + x.GetStr() + "\"")
		buf.WriteString(",")
	}

	buf.FixSymbol()
	buf.WriteString("}")
}

func (x *Example_NestedMsg) FastUnmarshal(p *jsonparser.Parser) {
	if x == nil {
		panic("type Example_NestedMsg is nil")
	}
	p.Symbol('{')
	for !p.IsSymbol('}') {
		key := p.Str()
		p.AssertSymbol(':')
		switch key {
		case "str":
			x.Str = p.Str()

		default:
			p.PassParse()
		}
		p.AssertSymbol(',')
	}
	p.AssertSymbol(',')
	p.Symbol('}')
}

var Example_NestedMsgPool sync.Pool

func Example_NestedMsgNew() *Example_NestedMsg {
	if v := Example_NestedMsgPool.Get(); v != nil {
		return v.(*Example_NestedMsg)
	}
	return &Example_NestedMsg{}
}
func (x *Example_NestedMsg) Destructor() {
	if x == nil {
		panic("type Example_NestedMsg is nil")
	}
	x.Str = ""
	Example_NestedMsgPool.Put(x)
}

func (x *Example_NestedMsg) IsEmptyStr() bool {
	return x.GetStr() == ""
}

func (x Example_NestedTyp) Get(i int32) Example_NestedTyp {
	if _, ok := Example_NestedTyp_name[i]; ok {
		return Example_NestedTyp(i)
	}
	panic("enum Example_NestedTypvalue do not match")
}

func (x Example_NestedTyp) GetByStr(s string) Example_NestedTyp {
	if i, ok := Example_NestedTyp_value[s]; ok {
		return Example_NestedTyp(i)
	}
	panic("enum Example_NestedTypvalue do not match")
}

func (x Example_NestedTyp) Set(i int32) {
	if _, ok := Example_NestedTyp_name[i]; ok {
		x = Example_NestedTyp(i)
		return
	}
	panic("enum Example_NestedTypvalue do not match")
}

func (x Example_NestedTyp) SetByStr(s string) {
	if i, ok := Example_NestedTyp_value[s]; ok {
		x = Example_NestedTyp(i)
		return
	}
	panic("enum Example_NestedTypvalue do not match")
}

func (x Typ) Get(i int32) Typ {
	if _, ok := Typ_name[i]; ok {
		return Typ(i)
	}
	panic("enum Typvalue do not match")
}

func (x Typ) GetByStr(s string) Typ {
	if i, ok := Typ_value[s]; ok {
		return Typ(i)
	}
	panic("enum Typvalue do not match")
}

func (x Typ) Set(i int32) {
	if _, ok := Typ_name[i]; ok {
		x = Typ(i)
		return
	}
	panic("enum Typvalue do not match")
}

func (x Typ) SetByStr(s string) {
	if i, ok := Typ_value[s]; ok {
		x = Typ(i)
		return
	}
	panic("enum Typvalue do not match")
}
